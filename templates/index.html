<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORA - Voice AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .global-status {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 1.1rem;
            text-align: center;
        }

        .personalities-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            max-width: 1200px;
            width: 100%;
        }

        .personality-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        .personality-card.active {
            border-color: #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            transform: scale(1.02);
        }

        .personality-card.inactive {
            opacity: 0.6;
            transform: scale(0.98);
        }

        .personality-title {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #FFD700;
        }

        .sun-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            height: 200px;
        }

        .sun {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #000;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .sun.listening {
            background: linear-gradient(45deg, #4A90E2, #357ABD);
            animation: pulse 2s infinite;
        }

        .sun.speaking {
            background: linear-gradient(45deg, #32CD32, #228B22);
            animation: speak 1s infinite;
        }

        .sun.processing {
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            animation: spin 2s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes speak {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.05); }
            75% { transform: scale(0.95); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-text {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .conversation-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .conversation-log::-webkit-scrollbar {
            width: 6px;
        }

        .conversation-log::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .conversation-log::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 3px;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .message.user {
            background: rgba(255, 215, 0, 0.2);
            margin-left: 20px;
        }

        .message.ai {
            background: rgba(74, 144, 226, 0.2);
            margin-right: 20px;
        }

        .timestamp {
            font-size: 0.8rem;
            color: #999;
            margin-bottom: 3px;
        }

        @media (max-width: 768px) {
            .personalities-container {
                grid-template-columns: 1fr;
            }
            
            .title {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">ORA - Voice AI</h1>
    </div>

    <div class="global-status" id="globalStatus">
        Choose a personality to start conversation
    </div>

    <div class="personalities-container">
        <!-- Empathetic Friend -->
        <div class="personality-card" id="empathetic-card">
            <div class="personality-title">Empathetic Friend</div>
            <div class="sun-container">
                <div class="sun" id="empathetic-sun">Disconnected</div>
            </div>
            <div class="status-text" id="empathetic-status">Ready to connect</div>
            <div class="controls">
                <button class="btn btn-primary" id="empathetic-start" onclick="startPersonality('empathetic')">Start Conversation</button>
                <button class="btn btn-secondary" id="empathetic-stop" onclick="stopPersonality('empathetic')" style="display: none;">Stop Conversation</button>
            </div>
            <div class="conversation-log" id="empathetic-log">
                <div class="message">Conversation will appear here...</div>
            </div>
        </div>

        <!-- Practical Coach -->
        <div class="personality-card" id="practical-card">
            <div class="personality-title">Practical Coach</div>
            <div class="sun-container">
                <div class="sun" id="practical-sun">Disconnected</div>
            </div>
            <div class="status-text" id="practical-status">Ready to connect</div>
            <div class="controls">
                <button class="btn btn-primary" id="practical-start" onclick="startPersonality('practical')">Start Conversation</button>
                <button class="btn btn-secondary" id="practical-stop" onclick="stopPersonality('practical')" style="display: none;">Stop Conversation</button>
            </div>
            <div class="conversation-log" id="practical-log">
                <div class="message">Conversation will appear here...</div>
            </div>
        </div>

        <!-- Wise Mentor -->
        <div class="personality-card" id="wise-card">
            <div class="personality-title">Wise Mentor</div>
            <div class="sun-container">
                <div class="sun" id="wise-sun">Disconnected</div>
            </div>
            <div class="status-text" id="wise-status">Ready to connect</div>
            <div class="controls">
                <button class="btn btn-primary" id="wise-start" onclick="startPersonality('wise')">Start Conversation</button>
                <button class="btn btn-secondary" id="wise-stop" onclick="stopPersonality('wise')" style="display: none;">Stop Conversation</button>
            </div>
            <div class="conversation-log" id="wise-log">
                <div class="message">Conversation will appear here...</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentActivePersonality = null;
        let sharedMicrophoneStream = null;
        let audioContext = null;
        let personalities = {
            empathetic: {
                websocket: null,
                recorder: null,
                isRecording: false,
                audioQueue: [],
                isPlayingAudio: false,
                nextStartTime: 0,
                voice: 'AURA', // Warm female voice
                systemPrompt: `You are The Empathetic Friend, a warm and caring AI companion. Your personality is:

- Deeply empathetic and emotionally supportive
- Always validate feelings and provide comfort
- Use warm, gentle language with lots of encouragement
- Ask thoughtful questions about emotions and well-being
- Offer emotional support rather than practical solutions
- Speak with a caring, nurturing tone
- Show genuine interest in the person's emotional state

Respond with empathy, warmth, and emotional intelligence. Always prioritize the person's feelings and emotional needs.`
            },
            practical: {
                websocket: null,
                recorder: null,
                isRecording: false,
                audioQueue: [],
                isPlayingAudio: false,
                nextStartTime: 0,
                voice: 'DACHER', // Confident male voice
                systemPrompt: `You are The Practical Coach, a direct and solution-focused AI mentor. Your personality is:

- Highly practical and results-oriented
- Focus on actionable solutions and clear next steps
- Use confident, direct language
- Ask specific questions to understand problems
- Provide concrete advice and strategies
- Speak with authority and conviction
- Help people get things done efficiently

Respond with practical solutions, clear guidance, and actionable advice. Always focus on helping people achieve their goals effectively.`
            },
            wise: {
                websocket: null,
                recorder: null,
                isRecording: false,
                audioQueue: [],
                isPlayingAudio: false,
                nextStartTime: 0,
                voice: 'STELLA', // Thoughtful voice
                systemPrompt: `You are The Wise Mentor, a thoughtful and philosophical AI guide. Your personality is:

- Deep, reflective, and philosophical
- Offer wisdom and broader perspectives
- Use thoughtful, measured language
- Ask profound questions that encourage self-reflection
- Share insights about life, growth, and meaning
- Speak with calm wisdom and patience
- Help people see the bigger picture

Respond with wisdom, thoughtful insights, and philosophical guidance. Always encourage deeper thinking and self-reflection.`
            }
        };

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 Initializing ORA Voice AI...');
            initializeAudioContext();
            updatePersonalityCardState();
        });

        function initializeAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('🔊 Web Audio API context initialized');
            } catch (error) {
                console.error('❌ Audio context error:', error);
            }
        }

        // Initialize microphone
        async function initializeMicrophone() {
            if (sharedMicrophoneStream) {
                console.log('🎙️ Using existing microphone stream');
                return sharedMicrophoneStream;
            }

            try {
                console.log('🎙️ Requesting microphone access...');
                sharedMicrophoneStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                console.log('🎙️ Microphone access granted');
                return sharedMicrophoneStream;
            } catch (error) {
                console.error('❌ Microphone access failed:', error);
                throw error;
            }
        }

        // Update personality card states
        function updatePersonalityCardState() {
            ['empathetic', 'practical', 'wise'].forEach(type => {
                const card = document.getElementById(`${type}-card`);
                if (currentActivePersonality === type) {
                    card.classList.add('active');
                    card.classList.remove('inactive');
                } else if (currentActivePersonality) {
                    card.classList.add('inactive');
                    card.classList.remove('active');
                } else {
                    card.classList.remove('active', 'inactive');
                }
            });

            // Update global status
            const globalStatus = document.getElementById('globalStatus');
            if (currentActivePersonality) {
                const personalityNames = {
                    empathetic: 'The Empathetic Friend',
                    practical: 'The Practical Coach',
                    wise: 'The Wise Mentor'
                };
                globalStatus.textContent = `Active: ${personalityNames[currentActivePersonality]}`;
            } else {
                globalStatus.textContent = 'Choose a personality to start conversation';
            }
        }

        // Start personality conversation
        async function startPersonality(personalityType) {
            try {
                console.log(`🎭 Activating personality: ${personalityType}`);

                // Stop current active personality if any
                if (currentActivePersonality && currentActivePersonality !== personalityType) {
                    console.log(`🔄 Deactivating current personality: ${currentActivePersonality}`);
                    await stopPersonality(currentActivePersonality);
                }

                currentActivePersonality = personalityType;
                updatePersonalityCardState();

                const personality = personalities[personalityType];
                
                // Update UI
                document.getElementById(`${personalityType}-status`).textContent = 'Connecting...';
                document.getElementById(`${personalityType}-sun`).className = 'sun processing';
                document.getElementById(`${personalityType}-start`).style.display = 'none';
                document.getElementById(`${personalityType}-stop`).style.display = 'inline-block';

                // Initialize microphone
                const stream = await initializeMicrophone();

                // Initialize Web Audio API for this personality
                personality.nextStartTime = 0;

                // Create WebSocket connection
                const wsUrl = `wss://api.hume.ai/v0/evi/chat?api_key=${await getApiKey()}`;
                personality.websocket = new WebSocket(wsUrl);

                personality.websocket.onopen = () => {
                    console.log(`✅ ${personalityType} connected to Hume EVI`);
                    
                    // Send session settings with voice configuration
                    const sessionSettings = {
                        type: 'session_settings',
                        voice: {
                            provider: 'HUME_AI',
                            name: personality.voice
                        },
                        system_prompt: personality.systemPrompt
                    };
                    
                    console.log(`🎵 ${personalityType} using voice: ${personality.voice}`);
                    personality.websocket.send(JSON.stringify(sessionSettings));

                    // Start recording
                    startRecording(personalityType, stream);
                    
                    document.getElementById(`${personalityType}-status`).textContent = 'Connected! Starting conversation...';
                    document.getElementById(`${personalityType}-sun`).className = 'sun listening';
                };

                personality.websocket.onmessage = (event) => {
                    handleWebSocketMessage(personalityType, JSON.parse(event.data));
                };

                personality.websocket.onclose = () => {
                    console.log(`🔌 ${personalityType} WebSocket closed`);
                    document.getElementById(`${personalityType}-status`).textContent = 'Disconnected';
                    document.getElementById(`${personalityType}-sun`).className = 'sun';
                    document.getElementById(`${personalityType}-sun`).textContent = 'Disconnected';
                };

                personality.websocket.onerror = (error) => {
                    console.error(`❌ ${personalityType} WebSocket error:`, error);
                };

            } catch (error) {
                console.error(`❌ Failed to start ${personalityType}:`, error);
                document.getElementById(`${personalityType}-status`).textContent = 'Connection failed';
                document.getElementById(`${personalityType}-sun`).className = 'sun';
                document.getElementById(`${personalityType}-start`).style.display = 'inline-block';
                document.getElementById(`${personalityType}-stop`).style.display = 'none';
            }
        }

        // Stop personality conversation
        async function stopPersonality(personalityType) {
            console.log(`🛑 Stopping ${personalityType} conversation`);
            
            const personality = personalities[personalityType];
            
            // Stop recording
            if (personality.recorder && personality.isRecording) {
                personality.recorder.stop();
                personality.isRecording = false;
                console.log(`🎙️ ${personalityType} recording stopped`);
            }

            // Close WebSocket
            if (personality.websocket) {
                personality.websocket.close();
                personality.websocket = null;
                console.log(`🔌 ${personalityType} WebSocket closed`);
            }

            // Clear audio queue
            personality.audioQueue = [];
            personality.isPlayingAudio = false;

            // Update UI
            document.getElementById(`${personalityType}-status`).textContent = 'Conversation stopped';
            document.getElementById(`${personalityType}-sun`).className = 'sun';
            document.getElementById(`${personalityType}-sun`).textContent = 'Disconnected';
            document.getElementById(`${personalityType}-start`).style.display = 'inline-block';
            document.getElementById(`${personalityType}-stop`).style.display = 'none';

            // Clear active personality if this was active
            if (currentActivePersonality === personalityType) {
                currentActivePersonality = null;
                updatePersonalityCardState();
            }

            console.log(`✅ ${personalityType} Status: Disconnected`);
        }

        // Start recording
        function startRecording(personalityType, stream) {
            const personality = personalities[personalityType];
            
            personality.recorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus'
            });

            personality.recorder.ondataavailable = (event) => {
                // Only send audio data if this personality is currently active
                if (currentActivePersonality === personalityType && event.data.size > 0) {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const base64Audio = reader.result.split(',')[1];
                        const audioMessage = {
                            type: 'audio_input',
                            data: base64Audio
                        };
                        personality.websocket.send(JSON.stringify(audioMessage));
                    };
                    reader.readAsDataURL(event.data);
                }
            };

            personality.recorder.start(100); // Send audio chunks every 100ms
            personality.isRecording = true;
            console.log(`🎙️ ${personalityType} recording started (ACTIVE)`);
        }

        // Handle WebSocket messages
        function handleWebSocketMessage(personalityType, message) {
            // Only process messages if this personality is currently active
            if (currentActivePersonality !== personalityType) {
                return;
            }

            const personality = personalities[personalityType];
            
            console.log(`📨 ${personalityType} received: ${message.type}`);

            switch (message.type) {
                case 'chat_metadata':
                    document.getElementById(`${personalityType}-status`).textContent = 'Listening... (speak now)';
                    console.log(`✅ ${personalityType} Status: Listening...`);
                    break;

                case 'user_message':
                    addToConversationLog(personalityType, 'user', message.message.content);
                    break;

                case 'assistant_message':
                    addToConversationLog(personalityType, 'ai', message.message.content);
                    document.getElementById(`${personalityType}-status`).textContent = 'AI is speaking...';
                    document.getElementById(`${personalityType}-sun`).className = 'sun speaking';
                    console.log(`🗣️ ${personalityType} Status: AI is speaking...`);
                    break;

                case 'audio_output':
                    if (message.data) {
                        console.log(`🔊 ${personalityType} received audio chunk (${message.data.length} chars)`);
                        playPersonalityAudio(personalityType, message.data);
                    }
                    break;

                case 'assistant_end':
                    document.getElementById(`${personalityType}-status`).textContent = 'Listening... (speak now)';
                    document.getElementById(`${personalityType}-sun`).className = 'sun listening';
                    console.log(`✅ ${personalityType} Status: Listening...`);
                    break;
            }
        }

        // Play audio for specific personality using Web Audio API
        async function playPersonalityAudio(personalityType, audioData) {
            // Only play audio if this personality is currently active
            if (currentActivePersonality !== personalityType) {
                console.log(`⏭️ ${personalityType} audio ignored (not active personality)`);
                return;
            }

            const personality = personalities[personalityType];
            
            try {
                // Decode base64 audio data
                const binaryString = atob(audioData);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Decode audio buffer
                const audioBuffer = await audioContext.decodeAudioData(bytes.buffer);
                
                // Create audio source
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);

                // Schedule seamless playback
                const startTime = Math.max(audioContext.currentTime, personality.nextStartTime);
                source.start(startTime);
                
                // Update next start time for seamless playback
                personality.nextStartTime = startTime + audioBuffer.duration;
                
                console.log(`🎵 ${personalityType} audio scheduled seamlessly at ${startTime.toFixed(3)}s`);

                // Handle playback end
                source.onended = () => {
                    console.log(`✅ ${personalityType} audio chunk ended`);
                };

            } catch (error) {
                console.error(`❌ ${personalityType} audio playback error:`, error);
            }
        }

        // Add message to conversation log
        function addToConversationLog(personalityType, sender, content) {
            const log = document.getElementById(`${personalityType}-log`);
            const message = document.createElement('div');
            message.className = `message ${sender}`;
            
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            
            const messageContent = document.createElement('div');
            messageContent.textContent = `${sender === 'user' ? 'You' : 'AI'}: ${content}`;
            
            message.appendChild(timestamp);
            message.appendChild(messageContent);
            log.appendChild(message);
            log.scrollTop = log.scrollHeight;
        }

        // Get API key from backend
        async function getApiKey() {
            try {
                const response = await fetch('/api/hume-key');
                const data = await response.json();
                return data.api_key;
            } catch (error) {
                console.error('❌ Failed to get API key:', error);
                throw error;
            }
        }
    </script>
</body>
</html>




